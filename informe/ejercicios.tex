\section{Ejercicio 1}

\emph{Completar la función broadcast\_block para que comunique a todos los demás nodos el nuevo bloque creado con el tag \texttt{TAG\_NEW\_BLOCK}. Cada nodo debe enviar los mensajes en un orden distinto a los demás nodos.}

Para que se envíen los mensajes en un orden distinto cada nodo hace el envío respetando el orden de los rangos, comenzando desde el nodo inmediatamente siguiente y ``dando la vuelta"\ para seguir con el de menor rango una vez que se llega al nodo de máximo rango. Es decir, el nodo de rango $i$ envía los mensajes en el orden de rangos $i+1 \mod N,\ i+2 \mod N,\ \dots,\ i+(N-1) \mod N$, donde $N$ es la cantidad de nodos.

Los mensajes se envían de forma no bloqueante con \texttt{MPI\_Isend} para que la lectura del bloque se pueda hacer concurrentemente. Si se usara \texttt{MPI\_Send}, cada pedido de envío comenzaría recién una vez que el llamado anterior haya terminado de leer el bloque, forzando una lectura secuencial.

Luego de hacer todos los pedidos de envío se espera a que los mismos finalicen con un llamado a \texttt{MPI\_Waitall}.


\section{Ejercicio 2}

\emph{Modificar el método nodo para que cree un nuevo thread que mine bloques mediante la función \texttt{proof\_of\_work}. Modificar las funciones de manera tal que entre los dos hilos del proceso no se produzcan condiciones de carrera. Además, mientras se envíe la información de un bloque recién creado a los demás, no se deben procesar los mensajes de nuevos bloques minados por otros.}

Para evitar condiciones de carrera usamos un mutex para la variable \texttt{last\_block\_in\_chain}. Hacemos lock de este mutex en \texttt{proof\_of\_work} antes de la copia del último bloque para comenzar a minar y lo liberamos apenas termina. Pedimos también el lock antes de verificar si cambió el último bloque y lo liberamos al salir de la guarda. Si el último bloque no cambió se copiará el nuevo bloque minado a \texttt{last\_block\_in\_chain} y se hará \texttt{broadcast\_block} manteniendo el lock durante todo esto. Esto es para evitar lecturas incorrectas del último bloque por parte del otro thread mientras se está cambiando y también para que no se procesen los mensajes de nuevos bloques minados por otros.

En el otro thread primero esperamos la llegada de un nuevo mensaje. Para ello usamos la función \texttt{MPI\_Probe} que nos permite determinar el información como el tag del mensaje antes de recibir los datos del mismo. Con esto podemos verificar entonces si el mensaje se trata de un nuevo nodo minado por otro (si el tag es \texttt{TAG\_NEW\_BLOCK}) o si es una solicitud de una cadena de bloques (si el tag es \texttt{TAG\_CHAIN\_HASH}) y utilizar un buffer adecuado para recibir el bloque o el hash enviado.

Cuando se trata de un nuevo bloque simplemente llamamos a la función \texttt{validate\_block\_for\_chain} luego de recibir el bloque. Esta, como se explica más adelante, va a solicitar el lock del mutex presentado antes. Luego, como el thread minero mantiene el lock del mismo cuando hace el broadcast, no se procesarán los mensajes de nuevos bloques mientras pasa eso.

Si el mensaje es un pedido de una cadena de bloques, el thread, luego de verificar que tiene el hash pedido en su diccionario, construye la cadena copiándola en un buffer hasta llegar a la longitud dada por \texttt{VALIDATION\_BLOCKS} o llegar al bloque de índice 1 (inclusive). Luego envía la cadena con un \texttt{MPI\_Send} poniendo en el parámetro \texttt{count} la cantidad de bloques de la cadena. Esta cantidad es cero cuando el hash pedido no se encuentra en el diccionario.


\section{Ejercicio 3}

\emph{Completar la función \texttt{validate\_block\_for\_chain} para que respete las reglas de consenso descriptas y no tenga condiciones de carrera con el thread que mina nuevos bloques.}

La implementación de \texttt{validate\_block\_for\_chain} es una traducción directa de los puntos mencionados en la sección \emph{Consenso} del enunciado.

Para evitar condiciones de carrera, antes de comparar el nuevo bloque con \texttt{last\_block\_in\_chain} y (posiblemente) hacer una migración, se pide el lock del mutex asociado a esta última variable; se lo libera una vez que se termina de hacer lo mencionado.

Las migraciones de cadena pueden tardar, haciendo que el thread mantenga la posesión del lock por tiempos prolongados. Esto es necesario ya que no se quiere que el thread minero tome un bloque incorrecto.


\section{Ejercicio 4}

\emph{Completar la función \texttt{verificar\_y\_migrar\_cadena} para que respete el protocolo descripto en la sección correspondiente.}

En la función \texttt{verificar\_y\_migrar\_cadena} primero le enviamos un mensaje al nodo que agregó el nuevo bloque solicitándole una cadena de bloques y luego esperamos a que la envíe.

Si recibimos algún bloque, comenzamos verificando que el hash y el índice del primero coincidan con el del bloque solicitado y que el hash sea correcto. Si esto se confirma, procedemos a recorrer la cadena verificando que los índices y los hashes de cada bloque sean correctos con respecto a la información del bloque anterior y, a su vez, vamos viendo si los bloques están o no en el diccionario de bloques. Si algún índice o hash es incorrecto o algún bloque es encontrado en el diccionario, dejamos de recorrer la cadena. En el primer caso la cadena es inválida y no la agregamos; en el segundo podemos reconstruir la cadena a partir del bloque encontrado.

Sólo cuando encontramos uno de los bloques de la cadena en el diccionario  reconstruimos la cadena y ponemos a \texttt{last\_block\_in\_chain} como el primer bloque de la cadena. Si la cadena es inválida (alguno de los bloques tiene información incorrecta) no la agregamos, y si la cadena es válida pero no encontramos ningún bloque de ella en el diccionario tampoco.

La implementación de la función no toma ninguna medida adicional para evitar condiciones de carrera ya que asume que se realizaron las acciones necesarias (lock de \texttt{last\_block\_in\_chain}) antes de ser llamada.


\section{Ejercicio 5}

\emph{Desarrolle un análisis del protocolo descripto en este trabajo que responda, al menos, a las siguientes preguntas:}

\emph{¿Puede este protocolo producir dos o más blockchains que nunca converjan?}

Si un nodo $a$ mina un bloque nuevo con índice $i$ y hace el broadcast, pero otro nodo $b$ mina otro bloque con el mismo índice (y también hace el broadcast) antes de recibir el broadcast de $a$, $b$ descartará el bloque enviado por $a$ cuando lo reciba porque tendrá el mismo índice (si $b$ no minó otro bloque ya) y $a$ descartará el bloque de $b$ porque tendrá menor o igual índice (menor si $a$ ya minó otro bloque). Esto podría suceder indefinidamente y, entonces, $a$ y $b$ producirían dos blockchains distintos que no convergen.

Otra forma por la que puede suceder esto es si los mensajes de nuevo bloque minado tardan mucho en llegar. Específicamente, si los mensajes de nuevo bloque minado entre (al menos) dos nodos tardan siempre más de 5 minutos, los nodos siempre descartarán los bloques recibidos y permanecerán en su blockchain, incluso si el índice del bloque recibido es distinto al del último bloque. Lo mismo sucede si por algún motivo los mensajes se transmiten incorrectamente por la red, invalidando la información de los bloques, o si directamente se pierden.

Puede suceder también que un nodo se atrase demasiado en el blockchain por algún motivo y cuando solicite una cadena de bloques no pueda reconstruirla ya que no tiene en su diccionario ningún bloque de la cadena. En este caso el nodo descartará la cadena y seguirá con su blockchain y, si cada vez que otro nodo agrega uno nuevo ocurre lo mismo, producirá un blockchain distinto al resto que no convergerá.

También es posible que se produzcan blockchains que no convergen por una combinación de los esceneraios mencionados.

\emph{¿Cómo afecta la demora o la pérdida en la entrega de paquetes al protocolo?}

Por lo explicado antes, la demora o pérdida en la entrega de paquetes puede aumentar la probabilidad y la cantidad de blockchains distintos en el sistema. Esto resulta, por un lado, en un menor nivel de seguridad o certeza de que un blockchain dado sea ``el correcto"\ y, por el otro, en una mayor cantidad de trabajo desperdiciado dado que más nodos minarán de un blockchain ``incorrecto"\ que en algún punto será (o puede llegar a ser) descartado.

\emph{¿Cómo afecta el aumento o la disminución de la dificultad del Proof-of-Work a los conflictos entre nodos y a la convergencia?}

Cuando disminuye la dificultad del Proof-of-Work los bloques se minan más rápido. Esto hace que la cantidad de conflictos sea mayor ya que los nodos podrán minar una mayor cantidad de bloques en el tiempo que tarda en llegar un bloque nuevo y, entonces, será más probable que este sea descartado. Por esta razón, también, se producirán más blockchains distintos que tardarán más (en términos de cantidad de bloques) en converger porque para hacerlo el nuevo bloque de un nodo deberá llegar a los otros lo suficientemente rápido (antes de que minen demasiados bloques) para que estos abandonen su blockchain.

Si la dificultad aumenta, en cambio, los tiempos de minado serán mayores y será menos probable que un nodo se adelante mucho en el blockchain antes de que llegue un nuevo bloque de parte de otro nodo. Por ende, la cantidad de conflictos disminuirá y la posibilidad de que aparezcan blockchains distintos será menor, por lo que será más ``fuerte"\ la convergencia.

Por lo mencionado antes, también, cuando la dificultad es menor los conflictos se darán con índices más alejados, porque se habrá minado una mayor cantidad de bloques entre que se hizo el broadcast de un bloque nuevo hasta que fue recibido. Pero cuando la dificultad aumenta, los conflictos serán entre índices más cercanos debido a que se podrán minar menos bloques en dicho período de tiempo.